# Ассемблер для X584ASM

Программа X584ASM является ассемблером для эмулятора
[X584](https://github.com/kodemeister/X584), который понимает набор команд
К584ВМ1 в формате, используемом в программе X584. 

X584ASM является консольной программой, аналогичной FASM, TASM, YASM и прочим
ассемблерам. Она преобразует код в текстовом формате в файл в формате X584,
который понимает как версия 1.33, так и версия 2.0 и выше.

## Работа с X584ASM

### Описание работы

X584ASM принимает на вход файл с расширением asm (возможно любое другое
расширение) и выдаёт файл с расширением x584 (расширение заменяется, если
есть или приписывается, если нет). Итоговый файл будет размещён в папке,
откуда запущена программа.

Чтобы задать название выходного файла, необходимо воспользоваться ключом
`-o` или `--output`, после которого следует путь к итоговому файлу. Запись

    $ ./x584asm -o dir/output.x584 source.asm

говорит, что из файла `source.asm` будет получен файл `dir/output.x584`.

В ходе работы X584ASM выводит сообщения о работе. При нормальной работе
для данного примера X584ASM выведет в консоль:

    $ ./x584asm -o dir/output.x584 source.asm
    This is X584ASM, version v0.2.9
    Input file: source.asm
    Output written on dir/output.x584

### Аргументы командной строки

- `-o` или `--output`

  Изменение пути к итоговому файлу. По умолчанию программа берёт путь
  к исходому файлу, оставляет только имя файла и заменяет его расширение
  на `.x584` (поведение аналогично комплиятору GCC с флагом `-c`).

- `-h` или `--help`

  Вывод краткой справки по команде.

- `-v` или `--version`

  Вывод версии программы.

### Лексическая структура

X584ASM разбивает исходный текст на знаки следующих типов:

- ключевые слова:

  `РОН0`, `РОН1`, `РОН2`, `РОН3`, `РОН4`, `РОН5`, `РОН6`, `РОН7`,
  `РР`, `РРР`, `ШИНвх`, `Швх`, `ШИНвых`, `ШВых`, `П`, `если`,
  `то`, `иначе`, `иди_на`, `ввод`, `останов`, `ноп`, `стоп`, `пусто`
  (только в составе `<ПУСТО>`, в другом месте - ошибка),
  `ПАЛУ0`, `ПАЛУ1`, `ПАЛУ2`, `ПАЛУ3`, `СДЛ1`, `СДЛ2`, `СДП1`, `СДП2`,
  `РРР0`, `РРР3`, `А15`, `В15`, `и`, `или`, `искл_или`, `СЛЛ`, `СЛП`,
  `СЦЛ`, `СЦП`, `САЛ`, `САП`;

  `RF0`, `RF1`, `RF2`, `RF3`, `RF4`, `RF5`, `RF6`, `RF7`, `WR`, `XWR`,
  `DI`, `DO`, `C`, `ALUCIN`, `if`, `then`, `else`, `goto`, `input`,
  `break`, `nop`, `halt`, `empty`, `ALUCOUT0`, `ALUCOUT1`, `ALUCOUT2`,
  `ALUCOUT3`, `CO0`, `CO1`, `CO2`, `CO3`, `C0`, `C1`, `C2`, `SL1`, `SL2`,
  `SR1`, `SR2`, `WRRT`, `WRLFT`, `XWRRT`, `XWRLFT`, `XWR0`, `XWR3`,
  `A15`, `B15`, `AMSB`, `BMSB`, `and`, `or`, `xor`, `LSL`, `LSR`, `RSL`,
  `RSR`, `ASL`, `ASR`;

- слова, состоящие из букв Юникода (категории Lu, Ll, Lt, Lm, Lo), 
  нижнего подчёркивания `'_'` и прочих символов из категории Pc,
  десятичных цифр и начинающиеся с буквы или нижнего подчёркивания;

- числа, состоящие из десятичных цифр;

- шестнадцатеричные числа, начинающиеся с `0x`;

- аннотации, начинающиеся с `;` или `#` и продолжающиеся до конца
  строки;

- символ `:=`;

- прочие символы.

Комментарии бывают однострочные (начинаются с `//`) и многострочные
(начинаются с `/*` и заканчиваются `*/`). Вложенные многострочные
комментарии не допускаются.

### Эквиваленты ключевых слов

| Русские ключевые слова | Английские ключевые слова |
|------------------------|---------------------------|
| `А15` (с русской А)    | `A15` (с англ. A), `AMSB` |
| `B15` (с русской В)    | `B15` (с англ. B), `BMSB` |
| `ввод`                 | `input`                   |
| `ВхПАЛУ`               | `ALUCIN`                  |
| `если`                 | `if`                      |
| `и`                    | `and`                     |
| `иди_на`               | `goto`                    |
| `или`                  | `or`                      |
| `иначе`                | `else`                    |
| `искл_или`             | `xor`                     |
| `НОП`                  | `NOP`                     |
| `останов`              | `break`                   |
| `П`                    | `C`                       |
| `ПАЛУ0`, `П0`          | `C0`, `CO0`, `ALUCOUT0`   |
| `ПАЛУ1`, `П1`          | `C1`, `CO1`, `ALUCOUT1`   |
| `ПАЛУ2`, `П2`          | `C2`, `CO2`, `ALUCOUT2`   |
| `ПАЛУ3`                | `CO3`, `ALUCOUT`          |
| `<ПУСТО>`              | `<EMPTY>`                 |
| `РОН0`                 | `RF0`                     |
| `РОН1`                 | `RF1`                     |
| `РОН2`                 | `RF2`                     |
| `РОН3`                 | `RF3`                     |
| `РОН4`                 | `RF4`                     |
| `РОН5`                 | `RF5`                     |
| `РОН6`                 | `RF6`                     |
| `РОН7`                 | `RF7`                     |
| `РР`                   | `WR`                      |
| `РРР`                  | `XWR`                     |
| `РРР0`                 | `XWR0`                    |
| `РРР3`                 | `XWR3`                    |
| `САЛ`                  | `ASL`                     |
| `САП`                  | `ASR`                     |
| `СДЛ1`                 | `SL1`, `WRLFT`            |
| `СДЛ2`                 | `SL2`, `XWRLFT`           |
| `СДП1`                 | `SR1`, `WRRT`             |
| `СДП2`                 | `SR2`, `XWRRT`            |
| `СЛЛ`                  | `LSL`                     |
| `СЛП`                  | `LSR`                     |
| `СЦЛ`                  | `RSL`                     |
| `СЦП`                  | `RSR`                     |
| `СТОП`                 | `HALT`                    |
| `то`                   | `then`                    |
| `ШИНвх`, `ШВх`         | `DI`                      |
| `ШИНвых`, `ШВых`       | `DO`                      |

### Синтаксис

Программа представлена в виде последовательности инструкций. Каждая
инструкция состоит из:

- метки в виде слова и двоеточия;

- опкода;

- управляющего оператора;

- одной аннотации, которая может быть вставлена после опкода или
  после управляющего оператора.

> [!CAUTION]
> В версии 0.2.10 недопустима вставка аннотации между меткой и
> опкодом.

### Формат опкода

Опкод может в начале иметь слово `Останов` или `Break`. Это означает,
что на месте этой инструкции будет установлена точка останова.

После опкода может идти слово `NOP`, `НОП`, `<ПУСТО>` или `<EMPTY>`.
Для X584 это будет означать, что в этом месте не будет никакой инструкции.

Вместо `BREAK NOP` можно использовать слово `HALT` или `СТОП`. Это будет
означать прекращение выполнения программы в данном месте.

Остальные выражения состоят из трёх частей: регистра-приёмника, выражения
операции и необязательного обозначения переноса. Между регистром-приёмником
и выражением операции стоит символ `=` или последовательность символов `:=`.

В качестве регистра-приёмника могут быть использованы: `РОН0`, `РОН1`, `РОН2`,
`РОН3`, `РОН4`, `РОН5`, `РОН6`, `РОН7`, `РР`, `РРР`, `ШИНвых`, `(РР, РРР)`,
а также их английские эквиваленты. 

В качестве выражения операции могут использоваться:

- арифметические выражения, состоящие из действий сложения и вычитания;

- логические выражения из двух операндов;

- выражения сдвига, состоящие из команды сдвига и арифметического выражения.

#### Арифметические выражения

Арифметические выражения могут состоять из произвольного числа операндов,
в качестве которых могут использоваться регистры общего назначения
`РОН0`, `РОН1`, `РОН2`, `РОН3`, `РОН4`, `РОН5`, `РОН6`, `РОН7`, 
рабочий регистр `РР`, расширенный рабочий регистр `РРР`, шина входа `ШИНвх`, 
входной перенос `П` или `ВхПАЛУ`, а также их английские эквиваленты. 
Операнды могут быть соединены знаками '+' и '-'.
Если перед операндом стоит знак '!', то значение этого операнда инвертируется
побитово.

В арифметических выражениях не могут повторяться операнды одного типа,
к которым применяются одни и те же действия, в частности, не может быть прибавлено
или вычтено два разных регистра общего назначения. Сложения и вычитания
однотипных величин взаимоуничтожаются.

Допустимо опускать операнд переноса (это будет означать значение ВхПАЛУ=0),
заменять его на числовое значение (0 или 1). В выражениях, содержащих вычитание
единицы (`- 1`), допустимо опускать и `- 1`, и `П`, и это будет означать, что
значение переноса будет равно 1.

> [!NOTE] 
> В выражениях вида `V := !П`, где `V` обозначает регистр-приёмник,
> символ входящего переноса можно заменять только на 0, поскольку 
> выражения вида `V := !1` не могут быть представлены одной инструкцией
> из набора инструкций К584ВМ1.

Возможны следующие арифметические операции:

- `РОН := ШИНвх`
- `ШИНвых := РОН`
- `РРР := РОН`
- `РР := ШИНвх`
- `РРР := ШИНвх`
- `ШИНвых := ШИНвх`
- `РРР := РОН + РР + П`
- `РР := РОН + ШИНвх + П`
- `РРР := РОН + ШИНвх + П`
- `РОН := РОН + ШИНвх + П`
- `РР := РОН + РРР + П`
- `РРР := РОН + РРР + П`
- `РОН := РРР + П`
- `РРР := РР + ШИНвх + П`
- `ШИНвых := РР + ШИНвх + П`
- `РР := РРР + ШИНвх + П`
- `РРР := РРР + ШИНвх + П`
- `ШИНвых := РРР + П`
- `РОН := !П`
- `РР := !П`
- `ШИНвых := !П`
- `РРР := !П`
- `РОН := РР - РОН - 1 + П`
- `РР := РР - РОН - 1 + П`
- `ШИНвых := РР - ШИНвх - 1 + П`
- `РР := РР - ШИНвх - 1 + П`
- `РР := РРР - ШИНвх - 1 + П`
- `РРР := РР - ШИНвх - 1 + П`
- `РРР := РРР - ШИНвх - 1 + П`
- `ШИНвых := РРР - ШИНвх - 1 + П`
- `РОН := РОН - РР - 1 + П`
- `РР := РОН - РР - 1 + П`
- `ШИНвых := ШИНвх - РР - 1 + П`
- `РР := ШИНвх - РР - 1 + П`
- `РР := ШИнвх - РРР - 1 + П`
- `РРР := ШИНвх - РР - 1 + П`
- `РРР := ШИНвх - РРР - 1 + П`
- `ШИНвых := ШИНвх - РРР - 1 + П`
- `РОН := РОН + РР + П`
- `РР := РОН + РР + П`
- `ШИНвых := ШИНвх + РР + П`
- `РОН := РР + П`
- `РР := РР + П`
- `ШИНвых := РР + П`
- `РР := РРР + П`
- `РРР := РР + П`
- `РРР := РРР + П`
- `ШИНвых := РРР + П`
- `РОН := !РР + П`
- `РР := !РР + П`
- `ШИНвых := !РР + П`
- `РР := !РРР + П`
- `РРР := !РР + П`
- `РРР := !РРР + П`
- `ШИНвых := !РРР + П`
- `РОН := РОН + П`
- `РР := РОН + П`
- `ШИНвых := ШИНвх + П`
- `РР := ШИНвх + П`
- `РРР := ШИНвх + П`
- `РОН := !РОН + П`
- `РР := !РОН + П`
- `ШИНвых := !ШИНвх + П`
- `РР := !ШИНвх + П`
- `РРР := !ШИНвх + П`

Здесь и далее `РОН` может обозначать любой из регистров общего назначения 
`РОН0`-`РОН7`.


#### Логические выражения

Логические выражения бывают следующих видов:

- побитовое И (`V := A and B`);

- побитовое Исключающее ИЛИ (`V := A xor B`);

- побитовое Исключающее ИЛИ-НЕ (`V := !(A xor B)`);

- побитовое И с НЕ к первому аргументу (`V := !A and B`);

- побитовое И с НЕ ко второму аргументу (`V := A and !B`);

- побитовое ИЛИ с НЕ ко второму аргументу (`V := A or !B`);

- побитовое ИЛИ с НЕ к первому аргументу (`V := !A or B`);

- побитовое ИЛИ (`V := A or B`).

Здесь `V` обозначает регистр-приёмник, `A` и `B` - операнды.

Допустима перестановка операндов местами.

Логические выражения возможны для следующих типов операндов:

- РОН и РР, результат в РОН;

- РОН и РР, результат в РР;

- ШИНвх и РР, результат в ШИНвых;

- ШИНвх и РР, результат в РР;

- ШИНвх и РРР, результат в РР;

- ШИНвх и РР, результат в РРР;

- ШИНвх и РРР, результат в РРР;

- ШИНвх и РРР, результат в ШИНвых.

#### Выражения сдвига

Выражения сдвига в качестве регистра-приёмника могут использовать
либо регистр РР, либо регистры РР и РРР в виде `(РР, РРР)`.

Для сдвига регистра РР возможны шесть команд:

- сдвиг циклический левый `РР := СЦЛ(РР + П)`;
- сдвиг циклический правый `РР := СЦП(РР + П)`;
- сдвиг арифметический левый `РР := САЛ(РР + П)`;
- сдвиг арифметический правый `РР := САП(РР + П)`;
- сдвиг логический левый `РР := СЛЛ(РР + П)`;
- сдвиг логический правый `РР := СЛП(РР + П)`.

Для сдвига `(РР, РРР)` возможны следующие команды:

- сдвиг циклический левый `(РР, РРР) := СЦЛ(РР + П, РРР)`, а также:
  - `(РР, РРР) := СЦЛ(РР - ШИНвх - 1 + П, РРР)`;
  - `(РР, РРР) := СЦЛ(РР + ШИНвх + П, РРР)`;
  - `(РР, РРР) := СЦЛ(РР - РОН - 1 + П, РРР)`;
  - `(РР, РРР) := СЦЛ(РР + РОН + П, РРР)`;
- сдвиг циклический правый `РР := СЦП(РР + П)`;
- сдвиг арифметический левый `РР := САЛ(РР + П)`;
- сдвиг арифметический правый `РР := САП(РР + П)`, а также:
  - `(РР, РРР) := САП(РР - ШИНвх - 1 + П, РРР)`;
  - `(РР, РРР) := САП(РР + ШИНвх + П, РРР)`;
  - `(РР, РРР) := САП(РР - РОН - 1 + П, РРР)`;
  - `(РР, РРР) := САП(РР + РОН + П, РРР)`;
- сдвиг логический левый `РР := СЛЛ(РР + П)`;
- сдвиг логический правый `РР := СЛП(РР + П)`.

#### Обозначение переноса

Обозначение переноса возможно в виде `(П=0)` или `(П=1)`, вместо `П`
может стоять `ВхПАЛУ` или английский эквивалент. 

### Формат управляющего оператора

#### Условный оператор

Условный оператор записывается в виде: 
`ЕСЛИ <флаг> ТО <адрес/метка> [ИНАЧЕ <адрес/метка>]`. На месте ключевых
слов могут стоять их англоязычные эквиваленты.

В качестве флага могут использоваться ПАЛУ0 (П0, C0, CO0, ALUCOUT0),
ПАЛУ1 (П1, C1, CO1, ALUCOUT1), ПАЛУ2 (П2, C2, CO2, ALUCOUT2),
ПАЛУ3 (П, C, CO3, ALUCOUT), СДЛ1 (SL1, WRLFT), СДП1 (SR1, WRRT),
СДЛ2 (SL2, XWRLFT), СДП2 (SR2, XWRRT), РРР0 (XWR0), РРР3 (XWR3), 
А15 (AMSB), B15 (BMSB). Перед флагом может стоять знак '!', который
обозначает, что берётся обратное значение флага.

Адрес перехода задаётся словом-меткой или десятичным числом.

#### Оператор ввода

Чтобы не вводить тестовое значение ШИНвх каждый раз при отладке программы, 
можно для удобства указать его непосредственно в коде программы. Для этого 
нужно прописать команду `input <число>`, или русский эквивалент: `ввод <число>`. 
Число может быть задано в двоичном, десятичном или шестнадцатеричном виде.

- Число в двоичном виде состоит из 16 знаков 0 или 1, либо из четырёх 
  групп по четыре знака 0 или 1, разделённых пробелами. 
  Пример: 1110 1101 0101 0101 или 1110110101010101.
 
- Число в десятичном виде записывается как в виде положительного числа 
  от 0 до 65535, так и в виде отрицательного числа от -1 до -32768. 
  Отрицательные числа преобразуются в дополнительный код. 
  Пример: 60757 или -4779. 

- Число в шестнадцатеричном виде начинается с символов 0x, за которыми 
  идёт до четырёх шестнадцатеричных цифр: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
  A (a), B (b), C (c), D (d), E (e), F (f). 
  Пример: 0xED55. 

Любое отклонение от формата записи обрабатывается как неверный оператор.

### Ошибки

Если в процессе обработки файлов возникает фатальная ошибка, компиляция
останавливается и работа программы прекращается. В консоль могут быть
выведены следующие сообщения:

- `! Fatal error: out of memory`

  Нехватка памяти для работы программы.

- `! Fatal error: input file not specified`

  Входной файл не указан.

- `! Fatal error: invalid option`

  Указан неверный параметр командной строки.

- `! Fatal error: option requires an argument`

  Параметр требует аргумента (такое бывает, если не указать после `-o`
  нужного имени файла)

- `! Fatal error: failed to open input file`

  Не удалось открыть исходный файл.

- `! Fatal error: failed to open output file`

  Не удалось создать итоговый файл.

Если ошибка возникла в процессе парсинга исходного файла, то она выводится
в следующем формате:

    ! Line <L>, column <C>: <Text>

где `<L>` - номер строки, `<C>` - номер столбца в кодоместах Юникода, 
`<Text>` - обозначение ошибки вместе с её номером.

Имеются следующие типы ошибок:

1. `Syntax error`

   Синтаксическая ошибка.

2. `',' expected`

   Ожидалась запятая в выражении расширенного сдвига.

3. `<ПУСТО> expected`

   Ожидался код пустой инструкции.

4. `Flag expected (ПАЛУ0,ПАЛУ1,ПАЛУ2,ПАЛУ3,!СДЛ1,!СДП1,!СДЛ2,!СДП2,РРР0,РРР3,А15,В15)`

   Ожидался флаг в условном выражении.

5. `Label or address expected`

   Ожидалась метка или адрес инструкции.

6. `'(' expected`

   Ожидалась открывающая скобка.

7. `')' expected`

   Ожидалась закрывающая скобка.

8. `Argument expected (РОН0-РОН7,РР,РРР,ШИНвх,Швх,П)`

   Ожидался аргумент.

9. `'then' or 'то' expected`

   Ожидалось слово `то` или `then` в условном выражении.

10. `'xor' expected`

    Ожидался оператор "исключающее или" в выражении вида `РР := !(РОН0 xor РР)`

11. `Invalid address`

    Неверный адрес перехода (адрес меньше 0 или больше 1023).

12. `Invalid carry value`

    Неправильное значение входного переноса (либо `(П=0), либо (П=1)`)

13. `Invalid number`

    Неверное число.

14. `Invalid opcode`

    Неправильная инструкция.

15. `Too many instructions`

    Слишком много инструкций.

16. `Too many labels`

    Слишком много меток.

17. `Unexpected number`

    Неожиданное число.

18. `Unexpected word`

    Неожиданное слово.

19. `Unexpected symbol`

    Неожиданный символ.

20. `Unexpected annotation`

    Неожиданная аннотация.
